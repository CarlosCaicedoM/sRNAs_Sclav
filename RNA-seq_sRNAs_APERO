#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul  6 15:59:27 2023

@author: usuario
"""


#conda install -c bioconda fastqc
#sudo apt install sra-toolkit
#conda install -c bioconda -c conda-forge multiqc
#conda create -n cutadaptenv cutadapt
#sudo apt install cutadapt
# conda install -c bioconda fastp
#sudo apt install bwa
#sudo apt install samtools
#pip install HTSeq
#pip install pydeseq2
#conda install -c conda-forge scanpy python-igraph leidenalg
#pip install gseapy
#pip install goatools
#pip install pysam
#sudo apt install bowtie2

#%%

from IPython import get_ipython
get_ipython().magic('reset -sf')


import subprocess
import os
import shutil
import multiqc
import pandas as pd
import re
import pickle as pkl
from pydeseq2.dds import DeseqDataSet
from pydeseq2.ds import DeseqStats
import scanpy as sc
import gseapy as gp
from gseapy.plot import gseaplot
import numpy as np
import matplotlib.pyplot as plt
import pysam
import gzip


#Create file to download your data
my_experiment = "S-enterica_APERO"
my_file = "/SraAccList_S-enterica_APERO.txt"
reference_genome = "/media/usuario/CACM/Documentos/sRNAs_Sclav/raw_data/S-enterica_APERO/GCF_000210855.2_ASM21085v2_genomic.fna"
reference_genome_gtf= "/media/usuario/CACM/Documentos/sRNAs_Sclav/raw_data/annotations_Streptococcus/GCF_000007465.2_ASM746v2_genomic.gtf"

cur_dir = os.getcwd()
path = os.path.join(cur_dir, "raw_data", my_experiment) 


try: 
    os.mkdir(path) 
except OSError as error: 
    print(error) 

my_data = cur_dir+my_file
#If you want to remove all whitespace characters (newlines and spaces) from the end of each line
with open(my_data) as f:
    lines = [line.rstrip() for line in f]
Accessions  = lines[0:-1]

# this will download the .sra files to ~/ncbi/public/sra/ (will create directory if not present)
for sra_id in Accessions:
    print ("Currently downloading: " + sra_id)
    fasterq = "fasterq-dump " + sra_id + " -O " + path
    print ("The command used was: " + fasterq)
    subprocess.call(fasterq, shell=True)
	
fastq_files = [file for file in os.listdir(path) if file.endswith(".fastq") ]
fastq_files_path = []
for i in fastq_files:
    fastq_files_path.append(os.path.join(path, i))
    
fastq_command =[]  
for i in fastq_files:
    fastq_command.append(os.path.join(path, i))
fastq_command.insert(0, "fastqc")
fastqc_outdir=os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastqc")

try:
    os.mkdir("results_rna_seq")
except OSError as error:
    print(error)  

try:
    os.mkdir(os.path.join("results_rna_seq", my_experiment))
except OSError as error:
    print(error)

try:
    os.mkdir(fastqc_outdir)
except OSError as error:
    print(error)  
   
fastq_command.append("-o")
fastq_command.append(fastqc_outdir)
fastq_command.append("-t")
fastq_command.append("4")
#--noextract
subprocess.call(fastq_command)

#Summarize all the fastqc results with multiQC
try:
    os.mkdir(os.path.join(cur_dir, "results_rna_seq", my_experiment, "multiqc"))
except OSError as error:
    print(error)
 
multiQC_command = ["multiqc", fastqc_outdir]
multiQC_command.append("-n")
multiQC_command.append(my_experiment)
multiQC_command.append("-o")
multiQC_command.append(os.path.join(cur_dir, "results_rna_seq", my_experiment, "multiqc"))
multiQC_command.append("-f")
multiQC_command.append("--profile-runtime") 
subprocess.call(multiQC_command)





#Filter the adpaters
try:
  os.mkdir(os.path.join(cur_dir, "results_rna_seq", my_experiment, "cutadapt"))
except OSError as error:
    print(error) 

adapter_5prime = "GTTCAGAGTTCTACAGTCCGACGATC"
adapter_3prime = "TGGAATTTCTCGGGTGCCAAGG"


#Cutadapt command for adapter trimming at both ends, 
#quality triming at both ends and filtering to only have reads with length >18nt


for i,j  in enumerate(fastq_files):
    cutadapt_command=["cutadapt", "-a", adapter_3prime, "-g",
                  adapter_5prime, "-q", "15,10", "-m", "18", 
                  "--cores=0", "-o",  
                  os.path.join(cur_dir, "results_rna_seq", my_experiment, "cutadapt", "trimmed_"+j), fastq_files_path[i]]

    subprocess.call(cutadapt_command)
              
                 
                 
#%% Quality control and filtering by fastp
try:
  os.mkdir(os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp"))
except OSError as error:
    print(error)

#if single-end

for i,j  in enumerate(fastq_files):
    fastp_command=["fastp", 
                   "-i", fastq_files_path[i], "-o",  
                   os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", "trimmed_"+j), 
                   "-j", j+".json", "-h", j+".html"]

    subprocess.call(fastp_command)

#If paired-end

for i,j  in enumerate(Accessions):
    fastp_command=["fastp", 
                   "-i", path+"/"+j+"_1.fastq",
                   "-I",  path+"/"+j+"_2.fastq",               
                   "-o", os.path.join(cur_dir, "results_rna_seq",
                                my_experiment, "fastp", "trimmed_"+j+"_1.fastq"), 
                   "-O", os.path.join(cur_dir, "results_rna_seq",
                                my_experiment, "fastp", "trimmed_"+j+"_2.fastq"),
                   "-j", j+".json", "-h", j+".html"]

    subprocess.call(fastp_command)

#Move the reports to the fastp folder
reports = [rep for rep in os.listdir(os.curdir) if (rep.endswith(".html") or rep.endswith(".json"))]  
for file_name in reports:
    shutil.move(file_name, os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp"))




"""fastp -i in.R1.fq.gz -I in.R2.fq.gz -o out.R1.fq.gz -O out.R2.fq.gz
for paired end data modify accordingly"""

#adapter trimming is enabled by default
#quality filtering is enabled by default. 
 #length filtering is enabled by default.
#-w number of threads 
#-detect_adapter_for_pe        
#by default, the auto-detection for adapter is for SE data input only,
#turn on this option to enable it for PE data

"""
-r, --cut_right move a sliding window from front to tail, 
if meet one window with mean quality < threshold, drop the bases in the 
window and the right part, and then stop. Use cut_right_window_size to set 
the widnow size, and cut_right_mean_quality to set the mean quality threshold. 
This is similar as the Trimmomatic SLIDINGWINDOW method
https://github.com/Simon-Leonard/APERO/tree/master/R
"""

#%% Align sequences to the reference genome  BWA

try:
  os.mkdir(os.path.join(cur_dir, "results_rna_seq", my_experiment, "BWA"))
except OSError as error:
    print(error)


fastq_filtered_folder = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp")
fastq_filtered = [fastq for fastq in os.listdir(fastq_filtered_folder) if fastq.endswith(".fastq") ]  

# generate the index genome file
command = ['bwa', 'index', reference_genome]
subprocess.run(command, check=True)


#SE data
for i in fastq_filtered:  
    # Comamand for BWA
    fastq_file = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", i)
    command = ["bwa", "mem", reference_genome, fastq_file]
    # redirect the output to the SAM file
    output_sam = os.path.join(cur_dir, "results_rna_seq",
                              my_experiment, "BWA", i)  +".sam"
    
    with open(output_sam, "w") as output_file:
        subprocess.run(command, stdout=output_file, check=True)
    


#PE data

for i in Accessions:  
    # Comamand for BWA
    fastq_file_1 = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", "trimmed_"+i+"_1.fastq")
    fastq_file_2 = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", "trimmed_"+i+"_2.fastq")
    command = ["bwa", "mem", reference_genome, fastq_file_1, fastq_file_2]
    # redirect the output to the SAM file
    output_sam = os.path.join(cur_dir, "results_rna_seq",
                              my_experiment, "BWA", i)  +".sam"
    
    with open(output_sam, "w") as output_file:
        subprocess.run(command, stdout=output_file, check=True)

#%%  Convert unsorted SAM files to sorted
def sort_sam_file(input_sam, output_sam):
    entries = []
    with pysam.AlignmentFile(input_sam, "r") as samfile:
        for entry in samfile:
            entries.append(entry)

    sorted_entries = sorted(entries, key=lambda x: (x.reference_name, x.reference_start))
    with pysam.AlignmentFile(output_sam, "w", header=samfile.header) as sorted_sam:
        for entry in sorted_entries:
            sorted_sam.write(entry)


alignment_sam_folder = os.path.join(cur_dir, "results_rna_seq", my_experiment, "BWA")
alignment_sam = [sam for sam in os.listdir(alignment_sam_folder) if sam.endswith(".sam") ]  

for alignment in alignment_sam: 
    input_sam = os.path.join(alignment_sam_folder, alignment)
    output_sam = os.path.join(alignment_sam_folder, "sorted" + alignment)
    sort_sam_file(input_sam, output_sam)



#%% Convert SAM files to BAM files as this is required by APERO


alignment_sam_folder = os.path.join(cur_dir, "results_rna_seq", my_experiment, "BWA")
alignment_sam = [sam for sam in os.listdir(alignment_sam_folder) if sam.endswith(".sam") ]  


def convert_sam_to_bam(sam_file, bam_file):
    # Open SAM file in reading mode
    sam = pysam.AlignmentFile(sam_file, "r")

    # Open BAM file in writing mode
    #"When using 'wbu' as the opening mode for the BAM file, 
    #it will be written to the file uncompressed."
    bam = pysam.AlignmentFile(bam_file, "wb", header=sam.header)

    # Read each register in SAM file and write in BAM file
    for read in sam:
        bam.write(read)

    # Close the files
    sam.close()
    bam.close()

for alignment in alignment_sam: 
    input_sam = os.path.join(alignment_sam_folder, alignment)
    output_bam = os.path.join(alignment_sam_folder, os.path.splitext(alignment)[0]+".bam")
    convert_sam_to_bam(input_sam, output_bam)

#%% Convert unsorted to sorted BAM files
alignment_bam = [bam for bam in os.listdir(alignment_sam_folder) if bam.endswith(".bam") ]  


for bam in alignment_bam: 
    input_bam = os.path.join(alignment_sam_folder, bam)    
    # Archivo de salida CRAM
    output_bam = os.path.join(alignment_sam_folder, "sorted_"+bam)
    
    # Command 1: samtools fixmate
    fixmate_cmd = ["samtools", "fixmate", "-u", "-m", input_bam, "-"]
    
    # Command 2: samtools sort
    sort_cmd = ["samtools", "sort", "-u", "-@2", "-T", os.path.join(alignment_sam_folder, "sort_tmp"), "-"]
    
    
    # Comando 3: samtools markdup
    markdup_cmd = ["samtools", "markdup", "-O", "bam,level=1", "-", output_bam]

   
    # Ejecutar los comandos en secuencia
    try:
        # Ejecutar comando 1
        fixmate_process = subprocess.Popen(fixmate_cmd, stdout=subprocess.PIPE)
        
        # Ejecutar comando 2 y establecer la entrada del proceso anterior como la salida
        sort_process = subprocess.Popen(sort_cmd, stdin=fixmate_process.stdout, stdout=subprocess.PIPE)
        fixmate_process.stdout.close()
        
        # Ejecutar comando 3 y establecer la entrada del proceso anterior como la salida
        markdup_process = subprocess.Popen(markdup_cmd, stdin=sort_process.stdout)
        sort_process.stdout.close()
        
        # Esperar a que se completen todos los procesos
        fixmate_process.wait()
        sort_process.wait()
        markdup_process.wait()
    
    except subprocess.CalledProcessError as e:
        print("Error:", e)
    

#%% Align sequences to the reference genome  Bowtie2

try:
  os.mkdir(os.path.join(cur_dir, "results_rna_seq", my_experiment, "Bowtie2"))
except OSError as error:
    print(error)


fastq_filtered_folder = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp")
fastq_filtered = [fastq for fastq in os.listdir(fastq_filtered_folder) if fastq.endswith(".fastq") ]  

# generate the index genome file

# Comando Bowtie2 para crear la base de datos de referencia
bowtie2_build_cmd = ["bowtie2-build", reference_genome, "genome"]
subprocess.run(bowtie2_build_cmd, check=True)


#SE data
for i in fastq_filtered:  
    fastq_file = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", i)
    output_sam = os.path.join(cur_dir, "results_rna_seq",
                              my_experiment, "Bowtie2", i)  +".sam"
    bowtie2_align_cmd = ["bowtie2", "-x",  "genome", "-U", i,  "-S",  output_sam]
    subprocess.run(bowtie2_align_cmd, check=True)
    


#PE data
for i in Accessions:  
    # Comamand for 
    input_fastq_r1 = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", "trimmed_"+i+"_1.fastq")
    input_fastq_r2 = os.path.join(cur_dir, "results_rna_seq", my_experiment, "fastp", "trimmed_"+i+"_2.fastq")
    output_sam = os.path.join(cur_dir, "results_rna_seq",
                              my_experiment, "Bowtie2", i)  +".sam"
    bowtie2_align_cmd = ["bowtie2", "-x", "genome", "-1", input_fastq_r1, 
                         "-2", input_fastq_r2, "-S", output_sam]
    subprocess.run(bowtie2_align_cmd, check=True)



 


#%% import rpy2.robjects as robjects


# Cargar paquetes de R necesarios
robjects.r('library(Rsamtools)')
robjects.r('library(reshape2)')
robjects.r('library(snowfall)')
robjects.r('library(APERO)')

# Ruta del archivo ptt
ptt_file = "E:/APERO/NC_016810.ptt"

# Ruta del archivo BAM
bam_file = "E:/APERO/SRR2149882_position_1_to_10kb.bam"

# Directorio de trabajo de APERO
work_dir = "E:/APERO/"

# Ejecutar detección de inicio 5'
robjects.r(f'res <- APERO_start_detection(work_dir = "{work_dir}", bam_name = "{bam_file}", ptt_file = "{ptt_file}", wmax = 10, min_dist = 10, enrichment = 0.1, min_read_number = 0, genome_size = 4878012)')

# Ejecutar detección de fin 3'
robjects.r(f'res2 <- APERO_end_detection(work_dir = "{work_dir}", start_table = res, mTEX_bam = "{bam_file}", readthrough_proportion = 0.01, Fmin=NA, thread_number = 8, genome_size = 4878012, ptt_file="{ptt_file}")')




